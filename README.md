# Macquarie University, Department of Computing

## COMP332 Programming Languages 2019

## Lintilla, a simple functional programming language.

### Introduction

[Lintilla](http://hitchhikers.wikia.com/wiki/Lintilla) is a language that contains elements from mainstream functional languages such as [ML](https://en.wikipedia.org/wiki/Standard_ML), [Haskell](https://www.haskell.org/), [Scala](https://www.scala-lang.org/) and [Scheme](https://en.wikipedia.org/wiki/Scheme_(programming_language)). It uses a syntax that has been borrowed from Dom's favourite systems programming language [Rust](https://www.rust-lang.org/).

The description here provides a brief overview of the Lintilla language and its syntax. Further detail about aspects such as checking the validity of names or types and translating a program into an executable form will be added when we work on the Lintilla code generator in assignment 3.

### The Lintilla language

The basic unit of a Lintilla program is the *expression*. There are no statements, their place is taken by expressions whose type is the special type `unit`. You can think of unit as a type which has only one value, called `()`, and it is this value that is returned by those constructs which otherwise might be regarded as returning nothing (like a procedure or a `while` loop).

A Lintilla program is comprised of a sequence of expressions of type `unit` separated by semicolons. For example, here is a simple program that binds the result of a simple computation to a variable and then prints the contents of that variable:

    let x = 2 + 3 * 4;
    print x

When this program is run it will print the value of the expression: the number
14.

*Block expressions* are used to build programs out of smaller expressions. A block expression is a pair of curly braces containing zero or more expressions separated by semicolons (`;`). The idea is that when a block is executed each expression in that block is executed in turn, and the value computed by the last expression becomes the value of that block. For example, here is a program consisting of a block expression that declares two variables and uses their values in the expression whose values if returned from the block:

    let x = {
       let a = 5;
       let b = a + 1;
       a * b
    };
    print x

This program will print the result of multiplying `a` by `b`, so 30 will be printed. Here the name `a` can be used in the definition of `b` since `b` is defined later, but that is a name analysis issue, so we don't need to worry about it for the moment. Notice, in particular, that the semicolon is used as an expression separator, not a line terminator; so the last line in this block isn't followed by a semicolon. An empty block `{}` has type `unit`.

*Variables* are *immutable*, in the sense that they are bound to a value when they are declared and they maintain the same value from there to the point where they go out of scope. An variable is declared and bound to a value in a `let` expression:

    let doms_var = 10;

The scope of a variable extends from the point where it is declared to the end of the smallest enclosing block; or to the end of the program if the variable is bound at the top-level.

*Functions* may also be declared, both at top level or within a block. For example here is the familiar factorial function given as a recursive function in Lintilla:

    fn factorial(n: int) -> int {
      if n = 0 { 1 } else { n * factorial(n-1) }
    }

This declaration defines a new function which takes a single parameter of type `int` and returns an `int` as its result. It introduces a new immutable variable called `factorial` which, as a first order approximation, we can think of as pointing to the code generated by compiling the function body. The result returned by a function is the value returned when its body, a block, is executed.

Functions may take more than one parameter:

    fn mod(n: int, m: int) -> int {
      n - (n / m) * m
    };
    
    print(mod(23,10))  // prints `3`, the remainder when `23` is divided by `10`.

A *procedure* is a function which returns no value, or more precisely it returns the unique value `()` of type `unit`. Procedures are declared by omitting the return type specification in a `fn` declaration:

    let x = 20;

    fn print_n_plus_x(n : int) {
      print x + n
    };

   print_n_plus_x(23)    // prints the value `43`

The same effect can be gained by using the the explicit return type `unit`:

    fn print_n_plus_x(n : int) -> unit {
      print x + n
    }

We do not distinguish declarations from other kinds of expressions for the purposes of parsing. That doesn't mean that it will always make sense to use a declaration wherever any other kind of expression is appropriate, but just that this isn't a decision that the parser will make. The places where declarations can legally occur will be determined, and enforced, by the Lintilla type checker.
    
*Control expressions* we have already seen the principle control expression provided by Lintilla, the `if` expression. We might note that the language specifies that `if` expressions must have both a _then_ and an _else_ clause and that these must both be blocks enclosed in curly braces.

*Expression* forms are interchangeable as long as they have the correct type. E.g., anywhere we can put a number can also take a block or some other kind of expression that evaluates to a number. For example, here is an artificial program that uses blocks nested inside an arithmetic operation:

    {
      let a = 3;
      a + 1
    } *
    {
      let b = 10;
      b - 1
    }
    
Or more concisely:

    { let a = 3; a + 1 } * { let b = 10; b - 1 }

We've seen a few different forms of expression: numbers, addition expressions, multiplication expressions and function call expressions. There are also other arithmetic operations, boolean values, boolean literals, relational and logical operators, and conditional expressions. The complete syntax of Lintilla is given below.

Finally Lintilla allows programmers to insert comments into their code. These begin with two slashes `//` and extend from there to the end of the line. Comments are ignored by the compiler, which treats them just like white space.

### Extensions

Programmer demand in recent moths has lead to Lintilla being extended to incorporate the following new constructs:

*Logical operators* and (`&&`), or (`||`) and not (`~`) whose semantics follows the usual conventions regarding *short circuit evaluation* of logical operators.

*Mutable arrays* which can contain values of any Lintilla type, including function and array types (hence multi-dimensional arrays), which are homogeneously typed (all entries in an array have the same type). Arrays are created using an `array` operator, dereferenced using the pling operator (`!` as in `BCPL`), extended using the append operation (`+=` as in `Scala`), and updated to contain new values using the assignment operator (`:=`).

*For loops* these are "genuine" `for` loops in the style of `Pascal` and its derivates rather than the kind of logically controlled `for` loop found in `C` and `Java`. Lintilla also provides:

- a `loop` construct which provides for the early termination of the current iteration of the smallest enclosing `for` loop and starts the next iteration of that loop, and 
- a `break` construct which immediately terminates the execution of the smallest enclosing `for` loop entirely, and returns control to the command that immediately follows that loop.

### Lintilla syntax

Here is a complete context-free grammar for the Lintilla language:

    program : (exp ";")* exp.
    
    exp : assignexp
        | appendexp
        | logexp
        | ifexp
        | printexp
        | forexp
        | loopexp
        | breakexp
        | letdecl
        | fndecl.

    logexp : logexp "&&" logexp
           | logexp "||" logexp
           | logexp "=" logexp
           | logexp "<" logexp
           | logexp "+" logexp
           | logexp "-" logexp
           | logexp "*" logexp
           | logexp "/" logexp
           | logexp "!" logexp
           | "-" logexp
           | "~" logexp
           | "false"
           | "true"
           | integer
           | array tipe
           | "length" "(" exp ")"
           | app
           | block
           | "(" exp ")".
 
    app : app "(" ((exp ",")* exp)? ")"
        | idnuse.

    block : "{" ((exp ";")* exp)? "}".

    assignexp : logexp ":=" logexp

    appendexp : logexp "+=" logexp

    forexp : "for" idndef "=" logexp "to" logexp ("step" logexp)? "do" block

    loopexp : "loop"

    breakexp : "break"

    ifexp : "if" exp block "else" block.
    
    printexp : "print" exp.
    
    letdecl : "let" idndef "=" exp.
    
    fndecl : "fn" idndef "(" ((paramdecl ",")* paramdecl)? ")" ("->" tipe)? block.
    
    paramdecl : idndef ":" tipe.

Finally, the syntax of types:

    tipe : "unit"
         | "bool"
         | "int"
         | "fn" "(" ((tipe ",")* tipe)? ")" "->" tipe
         | "array" tipe
         | "(" tipe ")".

We use the word `tipe` instead of `type` since the latter is a Scala keyword which prevents us from using it as the name of a parser in our code. A function type is specified using the syntax

    fn(type_1, type_2, ..., type_n) -> res_type
    
which denotes the type of a function that takes `n` parameters of types `type_1`,..., `type_n` and returns a result of type `res_type`. We might note that a procedure has a type of the form

    fn(type_1, type_2, ..., type_n) -> unit

and that Lintilla does not allow variables or parameters to have type `unit`.

#### Precedence and associativity

The grammar above is not immediately suitable for encoding as a parser. The `logexp` non-terminal is ambiguous since it makes no allowance for precedence and associativity of the operators. You should rewrite that grammar production to implement the following precedence and associativity rules:

- The following expression constructs have precedence as shown from lowest to highest with constructs on the same line having the same precedence:

  1. logical and (`&&`) and or (`||`)
  2. equal (`=`) and less (`<`) than
  3. addition (`+`) and subtraction (`-`)
  4. multiplication (`*`) and division (`\`)
  5. array dereferencing (`!`)
  6. all other kinds of expression

  The constructs in the highest precedence category include unary negation, logical not, blocks in curly braces and expressions in parentheses.

- All binary expression operators are left associative, except for the relational operators (equality and less than) which are not associative.
    
### Semantic rules

The following sections explain the semantic rules of Lintilla, including its type rules. Many languages allow name and type analysis to be handled separately. Lintilla is in this category because we can first identify which entity a name represents before we check whether typed entities are used legally.

The framework bundle for assignment 3 contains a semantic analyser module which implements the complete suite of these rules.

#### Name analysis

Like most languages, Lintilla name occurrences come in two varieties: defining occurrences (represented by `IdnDef` nodes in the tree), and applied occurrences (represented by `IdnUse` nodes). Defining occurrences appear as the defined name in 'let' definitions and function definitions, and as the names of function parameters. All other identifier occurrences are applied and occur as plain names in expressions.

For example, in the following program the occurrences of `f` and `g` at the beginnings of the `fn` definitions are defining occurrences, as are the appearances of `a` and `b` in their parameter sections.

    fn f(a : int) -> int {
        a + 1
    };
    
    fn g(b : fn(int) -> int) -> int {
        b(5)
    };
    
    print g(f)

The remaining identifiers are applied occurrences: the `a` in the second line, the `b` in the sixth line, and both `g` and `f` in the last line.

The scoping rules of Lintilla are very simple. An identifier defined in a block (by a `let` or `fn` declaration) can only be used later in that block (including in nested blocks). Its scope extends from the point at which it is defined to the end of the smallest enclosing block; or to the end of the program if the identifier is defined at the top-level. Thus, in the following program, the `p` on the last line is illegal because it is outside the scope of the definition of `p` within the inner block. The `p` on the third line is legal because it is inside the scope of the value definition of `p`.

    let b = {
        let p = 1;
        p + 1
     };
     print p + 2

A variable cannot be redefined within the same block, so the second line in the following code would cause an error

    let x = 1;
    let x = 2

it can, however, be redefined in a inner block so the following code is legal:

    let x = 1;
    {
        let x = 2;
        print x
    };
    print x

In the code from the `let` on the fourth line and the `}` on the sixth line the original binding of `x` to `1` is shadowed by a new binding of `x` to `2`; we might say that this is a _hole_ in the scope of the binding made at line `1`. So when executed this code will print the number `2` followed by the number `1`.

In a `let` binding the scope of the variable being does **not** include the initialisation expression of that `let`. So in the following example

    let x = 10;
    {
        let x = x * x;
        print x
    };
    print x

the `x` referred to in the initialisation expression `x * x` is that bound in the `let` on line `1`. So when executed this code will print the number `100` followed by the number `10`. This rule disallows the definition of `let` bound identifiers whose definitions depend on the value being bound, something that would be ill defined (why?).

On the other hand the function name identifier bound in a `fn` declaration **is** in scope in the body of the function being defined. This allows us to define (directly) recursive functions such as our old friend the factorial:

    fn fact(n: int) -> int {
        if n = 0 { 1 } else { n * fact(n-1) }
    }

In a `fn` declaration each parameter declares the binding of a new identifier whose scope extends throughout the body of the declared function. That scope also encompasses the parameter declarations to the right of a given one. The upshot of this rule is that it is illegal to give two parameters the same identifier or to attempt to rebind that identifier directly within the body of the function (although it can still be rebound inside an inner block within the body).

It should be noted that the actual scope of the function identifier bound in a `fn` declaration is that of the block within which that declaration is situated. It's body is a smaller scope within that enclosing one. This means that it **is** legal to rebind a function identifier within its own body. So for example, the following is semantically correct:

    fn l() { 
        let l = 10;
        print l
    }

The downside of rebinding the name of a function within its own body is that it is now not possible to make a recursive call.

Finally a `for` loop also starts a new scope, which includes its control variable, a defining occurrence, and extends to the end of the body of that loop. Its from, to, and step expressions are not included in that new scope, however, and they are evaluated in the enclosing scope. The control variable of a `for` loop may not be rebound in the body of that loop.

#### Type analysis

Lintilla has four forms of type: integers, Booleans, a trivial type and functions. The first three are indicated by the `int`, `bool` and `unit` type names (respectively). A function type is indicated by the `fn` type constructor:

    fn(type_1, ..., type_n) -> type
    
This denotes the type a a function which takes `n` parameters of types `type_1`, `type_2`, ..., `type_n` and returns a result of type `type`. For example, the type

    fn(int, bool) -> int
    
is the type of a function which takes two parameters, of types `int` and `bool`, and returns a  function of type `int`. It is legal for a function to take no parameters, in which case it would have a type of the form:

    fn() -> type

The `unit` type is used to denote the return type of functions, and other builtin constructs, that perform an action but don't actually return a result. This is often the case for functions whose purpose is to perform a side effect, like printing to the terminal. For example, the purpose of a `print` expression is to print a value computed by its operand, but it doesn't itself return a value. So an expression like

    print 10 + x
    
has type `unit`. Builtin operations of type `unit` play the role that statements play in other languages. Functions with return type `unit` are sometimes refereed to as _procedures_.

The type of a variable introduced in a `let` declaration is the type of the
expression to which it is bound in that definition. For example, in the code

    let x = 1;
    print x

we know that `x` is has type `int` since it is bound to an expression whose
type is integer.

In a `fn` declaration all types of defined identifiers, both parameter identifiers and the identifier of the function itself, are given explicitly. The type of each parameter is given as a type expression, separated from the declared identifier by a colon. The function type itself is constructed using the list of specified parameter types and the return type given in the function signature. So in the following function declaration

    fn fib(res1 : int, res2 : int, count : int) -> int {
        if (0 < count) {
            fib(res2, res1 + res2, count - 1)
        } else {
            res1
        }
    }

the parameter identifiers `res1`, `res2` and `count` are all declared to have the type `int` and the type of the function identifier `fib` is `fn(int, int, int) -> int`. If a function declaration lacks a return type specification (the `->` part), that is if it is a procedure declaration, then it is assumed to have return type `unit`. So the procedure

    fn print_4_times(n : int) {
        print n;
        print n;
        print n;
        print n
    }
    
has type `fn(int) -> unit`. It is not legal for a function to take a parameter of `unit` type, consequently it is not legal for a function type to have the type `unit` in a parameter position.

Functions may have parameters and return values of which are of a function type, for example: 

    fn iterate(f : fn(int) -> int, count : int) -> (fn(int) -> int) {
        fn iter(n : int, count : int) -> int {
            if count < 1 {
                n
            } else {
                iter(f(n), count - 1)
            }
        };
        
        fn res(n : int) -> int {
            iter(n, count)
        };
        
        res
    }

Every (legal) expression in Lintilla has a type. The following points describe how the type of an expression is determined and give any typing conditions that are imposed on the types of values that occur as expression operands:

- The Boolean expressions `true` and `false` are of type `bool`.
- Any constant integer expression is of type `int`.
- Any constant array expression `array t` (where `t` denotes any Lintilla type) has type `array t`.
- The type of an applied identifier occurrence is the type given in its corresponding defining occurrence.
- All of the expressions at the top level of a program must have type `unit`.
- All of the expressions in a block, except for the last one, must have type unit. The type of a block expression is the type of the final expression in its body or `unit` if the block is empty.
- `fn` and `let` declaration expressions have type `unit`.
- `print` expressions have type `unit`.
- `for`, `loop` and `break` expressions have type `unit`.
- assignment (`:=`) and array append (`+=`) expressions have type unit.
- The initialisation expression in a `let`, to the right of the `=`, can have any legal type except for `unit`.
- In a function declaration parameters can be given any legal type except for `unit` and its return type can be any legal type. The declared return type must equal the type of the block given as the function body.
- A function call `f(e_1,...,e_n)` must satisfy the following rules:
    - the expression `f` must have a function type `fn(type_1,type_2,...,type_m)->type`,
    - the number of actual parameters `n` must match the number of formal parameters `m` in the function type of `f`,
    - each actual parameter `e_r` (`r = 1,...,n`) must have the corresponding parameter type `type_r` given in the function type of `f`, and 
    - the expression `f(e_1,...,e_n)` itself has type given by the return type `type` given in the function type of `f`.
- The type of the condition expression in an `if` expression must be `bool`. The types of the _then_ and _else_ branches of the `if` expression can be of any type, but they must be of the same type as each other. The type of the `if` expression itself is the common type of its _then_ and _else_ blocks.
- the left and right hand operands of an assignment (`:=`) must have the same type.
- the right hand operand of an append (`+=`) can have any type `t`, and its left hand must have the corresponding type `array t`.
- the from, to and (optional) step expressions of a `for` loop must have type `int`.
- the (optional) step expression of a `for` must be a constant expression.
- the control variable of an `for` expression has type `int`.
- the block that comprises the body of a `for` must have type `unit`.
- The operands of addition, subtraction, multiplication and division expressions must be be of type `int` and their result is also of type `int`.
- The operands of and, or and not expressions must be of type `bool` and their result is also of type `bool`
- The operands of a less-than expression must be of type `int` and its result is of type `bool`.
- The operands of an equals expression must be of the same type either `int` or `bool` and its result is of type `bool`.
- In all other cases not listed above, an expression can be of any type.

---
[Dominic Verity](http://orcid.org/0000-0002-4137-6982)  
Last modified: 22 October 2019 
[Copyright (c) 2019 by Dominic Verity and Anthony Sloane. Macquarie University. All rights reserved.](http://mozilla.org/MPL/2.0/)

